@page "/certificates"
@using MauiSherpa.Core.Interfaces
@using MauiSherpa.Core.Requests.Apple
@using MauiSherpa.Services
@using Shiny.Mediator
@inject IMediator Mediator
@inject IAppleConnectService AppleService
@inject IAppleIdentityStateService IdentityState
@inject IAlertService AlertService
@inject IDialogService DialogService
@inject OperationModalService OperationModal
@inject MultiOperationModalService MultiOpModal
@inject ICertificateSyncService CertificateSyncService
@inject ICloudSecretsService CloudSecretsService
@inject ILocalCertificateService LocalCertificateService
@inject BlazorToastService ToastService
@inject ILoggingService Logger
@inject IEncryptedSettingsService SettingsService
@implements IDisposable
@inject IJSRuntime JS

<h1><i class="fas fa-certificate"></i> Certificates</h1>

<AppleIdentityPicker />

@if (IdentityState.SelectedIdentity != null)
{
    <div class="toolbar">
        <button class="btn btn-primary" @onclick="@(() => RefreshData(forceRefresh: true))" disabled="@isLoading">
            <i class="fas @(isLoading ? "fa-spinner fa-spin" : "fa-sync-alt")"></i> Refresh
        </button>
        <button class="btn btn-success" @onclick="ShowCreateDialog" disabled="@isLoading">
            <i class="fas fa-plus"></i> Create Certificate
        </button>
        @if (CloudSecretsService.ActiveProvider != null)
        {
            <button class="btn btn-outline-primary" @onclick="SyncAllFromCloud" disabled="@(isLoading || !HasCloudOnlyCerts)">
                <i class="fas fa-cloud-download-alt"></i> Install All from Cloud
            </button>
            <button class="btn btn-outline-primary" @onclick="SyncAllToCloud" disabled="@(isLoading || !HasLocalOnlyCerts)">
                <i class="fas fa-cloud-upload-alt"></i> Upload All to Cloud
            </button>
        }
    </div>

    <!-- Cloud Sync Hint -->
    @if (CloudSecretsService.ActiveProvider == null && !syncHintDismissed)
    {
        <div class="alert alert-info alert-dismissible">
            <div class="alert-content">
                <i class="fas fa-cloud info-icon"></i>
                <div>
                    <strong>Sync certificates across machines</strong>
                    <p>Configure a cloud secrets provider (like Infisical) in Settings to securely sync your signing certificates and private keys across all your development machines.</p>
                </div>
            </div>
            <button type="button" class="btn-close" @onclick="DismissSyncHint" title="Dismiss">×</button>
        </div>
    }

    <!-- Filter Section -->
    <div class="filter-section">
        <div class="search-box">
            <span class="search-icon"><i class="fas fa-search"></i></span>
            <input type="text" @bind="searchQuery" @bind:event="oninput" placeholder="Search certificates..." />
            @if (!string.IsNullOrEmpty(searchQuery))
            {
                <button class="clear-btn" @onclick="@(() => searchQuery = "")">×</button>
            }
        </div>
        <div class="filter-chips">
            <select @bind="filterType" class="filter-select">
                <option value="">All Types</option>
                <option value="DEVELOPMENT">Development</option>
                <option value="DISTRIBUTION">Distribution</option>
                <option value="DEVELOPER_ID">Developer ID</option>
            </select>
            <select @bind="filterPlatform" class="filter-select">
                <option value="">All Platforms</option>
                <option value="IOS">iOS</option>
                <option value="MAC">macOS</option>
            </select>
            <select @bind="filterStatus" class="filter-select">
                <option value="">All Status</option>
                <option value="valid">Valid</option>
                <option value="expiring">Expiring Soon</option>
                <option value="expired">Expired</option>
            </select>
        </div>
        @if (HasActiveFilters)
        {
            <button class="clear-filters-btn" @onclick="ClearFilters">Clear Filters</button>
        }
    </div>

    @if (!string.IsNullOrEmpty(errorMessage))
    {
        <div class="error-bar">@errorMessage</div>
    }

    <div class="results-info">
        Showing @FilteredCertificates.Count() of @certificates.Count certificates
    </div>

    <div class="cert-list">
        @if (isLoading && certificates.Count == 0)
        {
            <div class="loading-state">
                <div class="loading-spinner">
                    <i class="fas fa-certificate"></i>
                </div>
                <div class="loading-title">Loading Certificates</div>
                <div class="loading-description">Fetching certificates from App Store Connect...</div>
            </div>
        }
        else if (!FilteredCertificates.Any())
        {
            <div class="empty-state">
                <div class="empty-icon"><i class="fas fa-lock"></i></div>
                <div class="empty-title">@(certificates.Count == 0 ? "No certificates found" : "No certificates match filters")</div>
                <div class="empty-description">@(certificates.Count == 0 ? "Click \"Create Certificate\" to generate a new signing certificate" : "Try adjusting your search or filters")</div>
            </div>
        }
        else
        {
            @foreach (var cert in FilteredCertificates)
            {
                var isExpired = cert.ExpirationDate < DateTime.UtcNow;
                var isExpiringSoon = !isExpired && cert.ExpirationDate < DateTime.UtcNow.AddDays(30);
                var syncStatus = GetSyncStatus(cert);
                
                <div class="cert-card @(isExpired ? "expired" : isExpiringSoon ? "expiring" : "")">
                    <div class="cert-icon"><i class="fas fa-lock"></i></div>
                    <div class="cert-details">
                        <div class="cert-name">@cert.Name</div>
                        <div class="cert-serial">
                            Serial: <span class="@(demoMode ? "demo-blur" : "")">@cert.SerialNumber</span>
                            <button class="btn-copy" @onclick="@(() => CopyToClipboard(cert.SerialNumber))" title="Copy to clipboard">
                                <i class="fas fa-copy"></i>
                            </button>
                        </div>
                        <div class="cert-badges">
                            @if (!string.IsNullOrEmpty(cert.CertificateType))
                            {
                                <span class="badge badge-type">@FormatCertType(cert.CertificateType)</span>
                            }
                            @{ var formattedPlatform = FormatPlatform(cert.Platform); }
                            @if (!string.IsNullOrEmpty(formattedPlatform))
                            {
                                <span class="badge badge-platform">@formattedPlatform</span>
                            }
                            @if (isExpired)
                            {
                                <span class="badge badge-expired">Expired</span>
                            }
                            else if (isExpiringSoon)
                            {
                                <span class="badge badge-expiring">Expiring Soon</span>
                            }
                            else
                            {
                                <span class="badge badge-valid">Valid</span>
                            }
                            @* Sync status badge *@
                            @if (CloudSecretsService.ActiveProvider != null)
                            {
                                <span class="badge @GetSyncBadgeClass(syncStatus)" title="@GetSyncStatusTooltip(syncStatus)">
                                    @GetSyncStatusIcon(syncStatus) @GetSyncStatusText(syncStatus)
                                </span>
                            }
                        </div>
                        <div class="cert-expiry">
                            Expires: @cert.ExpirationDate.ToString("MMM dd, yyyy")
                        </div>
                    </div>
                    <div class="cert-actions">
                        @if (CloudSecretsService.ActiveProvider != null)
                        {
                            var currentCertId = cert.Id;
                            var currentSyncStatus = syncStatus;
                            <button class="btn btn-secondary btn-icon" @onclick="@(() => ToggleSyncMenu(currentCertId))" @onclick:stopPropagation="true" title="Sync">
                                <i class="fas fa-cloud"></i>
                            </button>
                            @if (openSyncMenuCertId == currentCertId)
                            {
                                <div class="cert-dropdown-menu">
                                    @if (currentSyncStatus == SecretLocation.LocalOnly || currentSyncStatus == SecretLocation.Both)
                                    {
                                        <button type="button" class="cert-dropdown-item" @onclick="@(() => HandleUploadClick(currentCertId))">
                                            <i class="fas fa-cloud-upload-alt"></i> Upload to Cloud
                                        </button>
                                        <button type="button" class="cert-dropdown-item danger" @onclick="@(() => DeleteLocalCertificate(cert))">
                                            <i class="fas fa-trash-alt"></i> Delete from Keychain
                                        </button>
                                    }
                                    @if (currentSyncStatus == SecretLocation.CloudOnly || currentSyncStatus == SecretLocation.Both)
                                    {
                                        <button type="button" class="cert-dropdown-item" @onclick="@(() => HandleInstallClick(currentCertId))">
                                            <i class="fas fa-download"></i> Install Locally
                                        </button>
                                        <button type="button" class="cert-dropdown-item danger" @onclick="@(() => DeleteFromCloud(cert))">
                                            <i class="fas fa-cloud"></i> Delete from Cloud
                                        </button>
                                    }
                                    @if (currentSyncStatus == SecretLocation.None)
                                    {
                                        <div class="cert-dropdown-item disabled">
                                            <i class="fas fa-exclamation-circle"></i> No private key
                                        </div>
                                    }
                                </div>
                            }
                        }
                        <button class="btn btn-secondary btn-icon" @onclick="@(() => ShowExportDialog(cert))" 
                                disabled="@isLoading" title="Export">
                            <i class="fas fa-file-export"></i>
                        </button>
                        <button class="btn btn-danger btn-icon" @onclick="@(() => RevokeCertificate(cert))" 
                                disabled="@isLoading" title="Revoke">
                            <i class="fas fa-ban"></i>
                        </button>
                    </div>
                </div>
            }
        }
    </div>
}

@if (showCreateDialog)
{
    <div class="modal-overlay" id="create-cert-modal">
        <div class="modal" @onclick:stopPropagation="true" role="dialog" aria-modal="true" aria-labelledby="create-cert-title">
            <div class="modal-header">
                <h2 id="create-cert-title">Create Certificate</h2>
                <button class="close-btn" @onclick="CloseCreateDialog">×</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>Certificate Type</label>
                    <select @bind="newCertType" class="form-control">
                        <option value="IOS_DEVELOPMENT">iOS Development</option>
                        <option value="IOS_DISTRIBUTION">iOS Distribution</option>
                        <option value="MAC_APP_DEVELOPMENT">Mac Development</option>
                        <option value="MAC_APP_DISTRIBUTION">Mac App Distribution</option>
                        <option value="MAC_INSTALLER_DISTRIBUTION">Mac Installer Distribution</option>
                        <option value="DEVELOPER_ID_APPLICATION">Developer ID Application</option>
                        <option value="DEVELOPER_ID_KEXT">Developer ID Kernel Extension</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Common Name (optional)</label>
                    <input type="text" @bind="newCertCommonName" class="form-control" 
                           placeholder="@Environment.MachineName" />
                    <small class="form-hint">Defaults to your machine name if not specified</small>
                </div>
                <div class="form-group">
                    <label>PFX Passphrase (optional)</label>
                    <input type="password" @bind="newCertPassphrase" class="form-control" 
                           placeholder="Leave empty for no passphrase" />
                    <small class="form-hint">Password to protect the exported certificate file</small>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" @onclick="CloseCreateDialog" disabled="@isCreating">
                    <i class="fas fa-times"></i> Cancel
                </button>
                <button class="btn btn-primary" @onclick="CreateCertificate" disabled="@isCreating">
                    <i class="fas @(isCreating ? "fa-spinner fa-spin" : "fa-plus")"></i> @(isCreating ? "Creating..." : "Create")
                </button>
            </div>
        </div>
    </div>
}

@if (showExportDialog && exportCertificate != null)
{
    <div class="modal-overlay" id="export-cert-modal">
        <div class="modal" @onclick:stopPropagation="true" role="dialog" aria-modal="true" aria-labelledby="export-cert-title">
            <div class="modal-header">
                <h2 id="export-cert-title">Export Certificate</h2>
                <button class="close-btn" @onclick="CloseExportDialog">×</button>
            </div>
            <div class="modal-body">
                <div class="cert-export-info">
                    <strong>@exportCertificate.Name</strong>
                    <div class="text-muted">@exportCertificate.CertificateType</div>
                </div>
                
                <div class="form-group">
                    <label>Export Type</label>
                    <div class="export-type-options">
                        <label class="radio-option">
                            <input type="radio" name="exportType" value="p12" checked="@(exportType == "p12")" @onchange="@(() => exportType = "p12")" />
                            <span class="radio-label">
                                <strong>P12 / PFX (with private key)</strong>
                                <small>Includes both public and private key - can be used for signing</small>
                            </span>
                        </label>
                        <label class="radio-option">
                            <input type="radio" name="exportType" value="cer" checked="@(exportType == "cer")" @onchange="@(() => exportType = "cer")" />
                            <span class="radio-label">
                                <strong>CER (public key only)</strong>
                                <small>Contains only the public certificate - cannot be used for signing</small>
                            </span>
                        </label>
                    </div>
                </div>
                
                @if (exportType == "p12")
                {
                    var localIdentity = localIdentities?.FirstOrDefault(i => 
                        i.SerialNumber?.Equals(exportCertificate?.SerialNumber, StringComparison.OrdinalIgnoreCase) == true);
                    if (localIdentity == null)
                    {
                        <div class="alert alert-warning">
                            <i class="fas fa-exclamation-triangle"></i>
                            Private key not found in local keychain. You can only export the public certificate.
                        </div>
                    }
                    else
                    {
                        <div class="form-group">
                            <label class="checkbox-label">
                                <input type="checkbox" @bind="exportWithPassword" />
                                <span>Protect with password</span>
                            </label>
                        </div>
                        
                        @if (exportWithPassword)
                        {
                            <div class="form-group">
                                <label>Password</label>
                                <input type="password" @bind="exportPassword" class="form-control" placeholder="Enter password" />
                            </div>
                            <div class="form-group">
                                <label>Confirm Password</label>
                                <input type="password" @bind="exportPasswordConfirm" class="form-control" placeholder="Confirm password" />
                                @if (!string.IsNullOrEmpty(exportPassword) && !string.IsNullOrEmpty(exportPasswordConfirm) && exportPassword != exportPasswordConfirm)
                                {
                                    <small class="form-error">Passwords do not match</small>
                                }
                            </div>
                        }
                    }
                }
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" @onclick="CloseExportDialog" disabled="@isExporting">
                    <i class="fas fa-times"></i> Cancel
                </button>
                <button class="btn btn-primary" @onclick="ExportCertificate" disabled="@(!CanExport)">
                    <i class="fas @(isExporting ? "fa-spinner fa-spin" : "fa-file-export")"></i> @(isExporting ? "Exporting..." : "Export")
                </button>
            </div>
        </div>
    </div>
}

<style>
    h1 { margin-bottom: 1.25rem; font-size: 1.75rem; color: var(--text-primary); }

    .toolbar { margin-bottom: 1rem; display: flex; gap: 0.75rem; flex-wrap: wrap; }
    .error-bar { background: var(--status-error-bg); color: var(--status-error-text); padding: 0.75rem 1rem; border-radius: 0.375rem; margin-bottom: 1rem; }

    /* Info Alert */
    .alert-info {
        background: linear-gradient(135deg, rgba(66, 153, 225, 0.1), rgba(66, 153, 225, 0.05));
        border: 1px solid rgba(66, 153, 225, 0.3);
        border-radius: 0.5rem;
        padding: 1rem;
        margin-bottom: 1rem;
        display: flex;
        align-items: flex-start;
        gap: 0.75rem;
    }

    .alert-info .alert-content {
        flex: 1;
        display: flex;
        gap: 0.75rem;
        align-items: flex-start;
    }

    .alert-info .info-icon {
        font-size: 1.5rem;
        color: var(--accent-primary);
        flex-shrink: 0;
        margin-top: 2px;
    }

    .alert-info strong {
        display: block;
        color: var(--text-primary);
        margin-bottom: 0.25rem;
    }

    .alert-info p {
        margin: 0;
        color: var(--text-secondary);
        font-size: 0.875rem;
        line-height: 1.5;
    }

    .alert-info .btn-close {
        background: none;
        border: none;
        font-size: 1.25rem;
        color: var(--text-secondary);
        cursor: pointer;
        padding: 0;
        line-height: 1;
        opacity: 0.6;
        transition: opacity 0.2s;
    }

    .alert-info .btn-close:hover {
        opacity: 1;
    }

    /* Filter Section Styles */
    .filter-section {
        background: var(--card-bg);
        border-radius: 0.5rem;
        padding: 1rem;
        margin-bottom: 1rem;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        align-items: center;
    }

    .search-box {
        position: relative;
        flex: 1;
        min-width: 200px;
    }

    .search-box input {
        width: 100%;
        padding: 0.625rem 36px 0.625rem 36px;
        border: 1px solid var(--border-color);
        border-radius: 0.375rem;
        font-size: 0.875rem;
        box-sizing: border-box;
    }

    .search-box input:focus {
        outline: none;
        border-color: var(--accent-primary);
        box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.15);
    }

    .search-icon {
        position: absolute;
        left: 0.75rem;
        top: 50%;
        transform: translateY(-50%);
        font-size: 0.875rem;
        opacity: 0.5;
    }

    .clear-btn {
        position: absolute;
        right: 0.5rem;
        top: 50%;
        transform: translateY(-50%);
        background: var(--border-color);
        border: none;
        border-radius: 50%;
        width: 1.25rem;
        height: 1.25rem;
        font-size: 0.875rem;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--text-muted);
    }

    .clear-btn:hover { background: var(--bg-hover); }

    .filter-chips {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
    }

    .filter-select {
        padding: 0.5rem 0.75rem;
        border: 1px solid var(--border-color);
        border-radius: 0.375rem;
        font-size: 0.8125rem;
        background: var(--card-bg);
        cursor: pointer;
        min-width: 120px;
    }

    .filter-select:focus {
        outline: none;
        border-color: var(--accent-primary);
    }

    .clear-filters-btn {
        padding: 0.5rem 0.75rem;
        background: none;
        border: 1px solid var(--border-color);
        border-radius: 0.375rem;
        font-size: 0.8125rem;
        color: var(--text-muted);
        cursor: pointer;
    }

    .clear-filters-btn:hover {
        background: var(--bg-tertiary);
        color: var(--text-secondary);
    }

    .results-info {
        font-size: 0.8125rem;
        color: var(--text-muted);
        margin-bottom: 0.75rem;
    }

    .btn { 
        padding: 0.625rem 1.25rem; 
        border: none; 
        border-radius: 0.375rem; 
        font-size: 0.875rem; 
        cursor: pointer; 
        transition: all 0.2s ease;
        display: inline-flex;
        align-items: center;
        gap: 0.375rem;
    }
    .btn i { font-size: 0.75rem; }
    .btn-icon {
        width: 2rem; height: 2rem; padding: 0;
        display: inline-flex; align-items: center; justify-content: center;
        border-radius: 0.375rem; font-size: 0.8125rem;
    }
    .btn-icon i { font-size: 0.8125rem; margin: 0; }
    .btn-primary { background-color: var(--accent-primary); color: white; }
    .btn-primary:hover:not(:disabled) { background-color: var(--accent-primary-hover); }
    .btn-success { background-color: var(--accent-success); color: white; }
    .btn-success:hover:not(:disabled) { background-color: var(--accent-success-hover); }
    .btn-secondary { background-color: var(--bg-hover); color: var(--text-secondary); }
    .btn-secondary:hover:not(:disabled) { background-color: var(--bg-tertiary); }
    .btn-danger { background-color: #f56565; color: white; }
    .btn-danger:hover:not(:disabled) { background-color: var(--accent-danger); }
    .btn-sm { padding: 0.375rem 0.75rem; font-size: 0.8125rem; }
    .btn:disabled { opacity: 0.6; cursor: not-allowed; }

    .cert-list { display: flex; flex-direction: column; gap: 0.75rem; margin-bottom: 1.25rem; }

    .cert-card {
        background: var(--card-bg);
        border-radius: 0.5rem;
        padding: 1.25rem;
        display: flex;
        align-items: flex-start;
        gap: 1rem;
        box-shadow: var(--card-shadow);
        border-left: 0.25rem solid var(--accent-success);
    }

    .cert-card.expired { border-left-color: #f56565; opacity: 0.7; }
    .cert-card.expiring { border-left-color: var(--accent-warning); }

    .cert-icon { font-size: 2.25rem; color: #6b46c1; }
    .cert-icon i { font-size: 1.75rem; }
    .cert-details { flex: 1; }
    .cert-name { font-weight: 600; font-size: 1rem; color: var(--text-primary); }
    .cert-serial { 
        font-family: monospace; 
        font-size: 0.75rem; 
        color: var(--text-muted); 
        margin-top: 0.25rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    .cert-expiry { font-size: 0.8125rem; color: var(--text-muted); margin-top: 0.5rem; }
    .cert-badges { display: flex; flex-wrap: wrap; gap: 0.5rem; margin-top: 0.5rem; }
    .cert-actions { display: flex; gap: 0.25rem; align-items: center; position: relative; }

    .btn-copy {
        background: none;
        border: none;
        color: #a0aec0;
        cursor: pointer;
        padding: 2px 0.375rem;
        font-size: 0.75rem;
        border-radius: 0.25rem;
        transition: all 0.15s;
        flex-shrink: 0;
    }
    .btn-copy:hover {
        color: var(--accent-primary);
        background: var(--bg-hover);
    }

    .badge { padding: 2px 0.625rem; border-radius: 0.75rem; font-size: 0.75rem; font-weight: 500; }
    .badge-type { background: #faf5ff; color: #6b46c1; }
    .badge-platform { background: #bee3f8; color: #2c5282; }
    .badge-valid { background: var(--status-success-bg); color: var(--status-success-text); }
    .badge-expiring { background: var(--status-warning-bg); color: var(--status-warning-text); }
    .badge-expired { background: var(--status-error-bg); color: var(--status-error-text); }
    
    /* Sync status badges */
    .badge-sync-both { background: var(--sync-synced-bg); color: var(--sync-synced-text); }
    .badge-sync-local { background: var(--sync-local-bg); color: var(--sync-local-text); }
    .badge-sync-cloud { background: var(--sync-cloud-bg); color: var(--sync-cloud-text); }
    .badge-sync-none { background: var(--sync-none-bg); color: var(--sync-none-text); }
    
    /* Sync dropdown menu */
    .cert-dropdown-menu {
        position: absolute;
        right: 0;
        top: 100%;
        margin-top: 0.25rem;
        min-width: 180px;
        background: var(--card-bg);
        border: 1px solid var(--border-color);
        border-radius: 0.5rem;
        box-shadow: 0 0.25rem 1rem rgba(0,0,0,0.15);
        z-index: 100;
        padding: 0.25rem 0;
    }
    .cert-dropdown-item {
        display: flex; align-items: center; gap: 0.5rem;
        width: 100%; padding: 7px 0.875rem;
        border: none; background: none;
        color: var(--text-primary); font-size: 0.8125rem;
        cursor: pointer; text-align: left;
        transition: background 0.1s;
    }
    .cert-dropdown-item:hover:not(.disabled) { background: var(--bg-tertiary); }
    .cert-dropdown-item.disabled { color: var(--text-muted); cursor: default; opacity: 0.5; }
    .cert-dropdown-item i { font-size: 0.75rem; width: 0.875rem; text-align: center; color: var(--text-secondary); }
    .cert-dropdown-item.danger { color: var(--accent-danger, #e53e3e); }
    .cert-dropdown-item.danger i { color: var(--accent-danger, #e53e3e); }

    .empty-state { background: var(--card-bg); border-radius: 0.5rem; padding: 3.75rem 2.5rem; text-align: center; box-shadow: var(--card-shadow); }
    .empty-icon { font-size: 48px; margin-bottom: 1rem; color: #a0aec0; }
    .empty-icon i { font-size: 48px; }
    .empty-title { font-size: 1.125rem; font-weight: 600; color: var(--text-primary); margin-bottom: 0.5rem; }
    .empty-description { color: var(--text-muted); font-size: 0.875rem; }

    /* Modal styles */
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
    }

    .modal {
        background: var(--card-bg);
        border-radius: 0.75rem;
        width: 90%;
        max-width: 500px;
        max-height: 90vh;
        overflow-y: auto;
        box-shadow: 0 1.25rem 3.75rem rgba(0, 0, 0, 0.3);
    }

    .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 1.25rem 1.5rem;
        border-bottom: 1px solid var(--border-color);
    }

    .modal-header h2 { margin: 0; font-size: 1.25rem; color: var(--text-primary); }

    .close-btn {
        background: none;
        border: none;
        font-size: 1.5rem;
        color: var(--text-muted);
        cursor: pointer;
        padding: 0;
        line-height: 1;
    }

    .modal-body { padding: 1.5rem; }
    .modal-footer {
        display: flex;
        justify-content: flex-end;
        gap: 0.75rem;
        padding: 1rem 1.5rem;
        border-top: 1px solid var(--border-color);
        background: var(--bg-tertiary);
        border-radius: 0 0 0.75rem 0.75rem;
    }

    .form-group { margin-bottom: 1.25rem; }
    .form-group label { display: block; font-weight: 500; margin-bottom: 0.5rem; color: var(--text-secondary); }
    .form-control {
        width: 100%;
        padding: 0.625rem 0.75rem;
        border: 1px solid var(--border-color);
        border-radius: 0.375rem;
        font-size: 0.875rem;
        box-sizing: border-box;
    }
    .form-control:focus { outline: none; border-color: var(--accent-primary); box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.15); }
    .form-hint { display: block; margin-top: 0.25rem; font-size: 0.75rem; color: var(--text-muted); }
    .form-error { display: block; margin-top: 0.25rem; font-size: 0.75rem; color: var(--status-error-text); }
    
    /* Export dialog styles */
    .cert-export-info {
        background: var(--bg-secondary);
        padding: 0.75rem 1rem;
        border-radius: 0.5rem;
        margin-bottom: 1.25rem;
    }
    
    .export-type-options {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
    }
    
    .radio-option {
        display: flex;
        align-items: flex-start;
        gap: 0.75rem;
        padding: 0.75rem 1rem;
        border: 1px solid var(--border-color);
        border-radius: 0.5rem;
        cursor: pointer;
        transition: border-color 0.15s, background 0.15s;
    }
    
    .radio-option:hover {
        background: var(--bg-hover);
    }
    
    .radio-option input[type="radio"] {
        margin-top: 0.25rem;
    }
    
    .radio-option input[type="radio"]:checked + .radio-label {
        color: var(--accent-primary);
    }
    
    .radio-label {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
    }
    
    .radio-label strong {
        font-size: 0.875rem;
    }
    
    .radio-label small {
        font-size: 0.75rem;
        color: var(--text-muted);
    }
    
    .checkbox-label {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        cursor: pointer;
    }
    
    .checkbox-label input[type="checkbox"] {
        width: 18px;
        height: 18px;
    }
    
    .alert {
        padding: 0.75rem 1rem;
        border-radius: 0.5rem;
        margin-bottom: 1rem;
        display: flex;
        align-items: center;
        gap: 0.625rem;
    }
    
    .alert-warning {
        background: #fef3cd;
        color: #856404;
        border: 1px solid #ffc107;
    }
</style>

@code {
    private List<AppleCertificate> certificates = new();
    private bool isLoading = false;
    private bool isCreating = false;
    private bool demoMode = false;
    private string errorMessage = "";
    
    // Filter state
    private string searchQuery = "";
    private string filterType = "";
    private string filterPlatform = "";
    private string filterStatus = "";
    
    // Create dialog state
    private bool showCreateDialog = false;
    private string newCertType = "IOS_DEVELOPMENT";
    private string newCertCommonName = "";
    private string newCertPassphrase = "";
    
    // Export dialog state
    private bool showExportDialog = false;
    private bool isExporting = false;
    private AppleCertificate? exportCertificate = null;
    private string exportType = "p12";
    private bool exportWithPassword = false;
    private string exportPassword = "";
    private string exportPasswordConfirm = "";
    private IReadOnlyList<LocalSigningIdentity>? localIdentities = null;
    
    // Sync state
    private Dictionary<string, CertificateSecretInfo> syncStatuses = new();
    private string? openSyncMenuCertId = null;
    private bool syncHintDismissed = false;
    private const string SyncHintDismissedKey = "CertificatesSyncHintDismissed";
    
    private bool CanExport => exportCertificate != null && 
        !isExporting && 
        (exportType == "cer" || 
         (exportType == "p12" && 
          localIdentities?.Any(i => i.SerialNumber?.Equals(exportCertificate.SerialNumber, StringComparison.OrdinalIgnoreCase) == true) == true &&
          (!exportWithPassword || (exportPassword == exportPasswordConfirm && !string.IsNullOrEmpty(exportPassword)))));

    private bool HasActiveFilters => !string.IsNullOrEmpty(searchQuery) || 
                                      !string.IsNullOrEmpty(filterType) || 
                                      !string.IsNullOrEmpty(filterPlatform) ||
                                      !string.IsNullOrEmpty(filterStatus);

    private IEnumerable<AppleCertificate> FilteredCertificates => certificates
        .Where(c => string.IsNullOrEmpty(searchQuery) || 
                    c.Name.Contains(searchQuery, StringComparison.OrdinalIgnoreCase) ||
                    c.SerialNumber.Contains(searchQuery, StringComparison.OrdinalIgnoreCase))
        .Where(c => string.IsNullOrEmpty(filterType) || (c.CertificateType?.Contains(filterType, StringComparison.OrdinalIgnoreCase) ?? false))
        .Where(c => string.IsNullOrEmpty(filterPlatform) || (c.Platform?.Contains(filterPlatform, StringComparison.OrdinalIgnoreCase) ?? false))
        .Where(c => string.IsNullOrEmpty(filterStatus) || GetCertStatus(c) == filterStatus)
        .OrderByDescending(c => c.ExpirationDate > DateTime.UtcNow) // Valid first
        .ThenBy(c => c.ExpirationDate);

    // Computed properties for bulk sync buttons
    private bool HasCloudOnlyCerts => syncStatuses.Values.Any(s => s.Location == SecretLocation.CloudOnly);
    private bool HasLocalOnlyCerts => syncStatuses.Values.Any(s => s.Location == SecretLocation.LocalOnly);

    private string GetCertStatus(AppleCertificate cert)
    {
        if (cert.ExpirationDate < DateTime.UtcNow) return "expired";
        if (cert.ExpirationDate < DateTime.UtcNow.AddDays(30)) return "expiring";
        return "valid";
    }

    private void ClearFilters()
    {
        searchQuery = "";
        filterType = "";
        filterPlatform = "";
        filterStatus = "";
    }

    protected override async Task OnInitializedAsync()
    {
        try { var settings = await SettingsService.GetSettingsAsync(); demoMode = settings.Preferences.DemoMode; } catch { }
        IdentityState.OnSelectionChanged += OnIdentityChanged;
        
        // Load sync hint dismissed preference
        syncHintDismissed = Preferences.Default.Get(SyncHintDismissedKey, false);
        
        // Initialize cloud secrets service to load active provider
        await CloudSecretsService.InitializeAsync();
        
        if (IdentityState.SelectedIdentity != null)
            await RefreshData();
    }

    private void DismissSyncHint()
    {
        syncHintDismissed = true;
        Preferences.Default.Set(SyncHintDismissedKey, true);
        StateHasChanged();
    }

    private void OnIdentityChanged()
    {
        InvokeAsync(async () =>
        {
            await RefreshData();
            StateHasChanged();
        });
    }

    public void Dispose()
    {
        IdentityState.OnSelectionChanged -= OnIdentityChanged;
        foreach (var id in _activeModals)
            try { JS.InvokeVoidAsync("modalInterop.dispose", id); } catch { }
        _dotNetRef?.Dispose();
    }

    private async Task RefreshData(bool forceRefresh = false)
    {
        if (IdentityState.SelectedIdentity == null) return;

        isLoading = true;
        errorMessage = "";
        
        ToastMessage? toast = null;
        if (forceRefresh)
        {
            toast = ToastService.Show("Refreshing certificates...", ToastType.Info);
        }
        
        try
        {
            // Invalidate local certificate cache on force refresh
            if (forceRefresh)
            {
                LocalCertificateService.InvalidateCache();
            }
            
            // If force refresh, invalidate the mediator cache first
            if (forceRefresh)
            {
                await Mediator.FlushStores($"apple:certs:{IdentityState.SelectedIdentity.Id}");
            }
            
            var request = new GetCertificatesRequest(IdentityState.SelectedIdentity.Id);
            var (_, result) = await Mediator.Request(request);
            certificates = result.ToList();
            
            // Load sync statuses if cloud provider is configured
            await LoadSyncStatuses();
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to load certificates: {ex.Message}";
        }
        finally
        {
            isLoading = false;
            if (toast != null) ToastService.Dismiss(toast);
            await InvokeAsync(StateHasChanged);
        }
    }
    
    private async Task LoadSyncStatuses()
    {
        if (certificates.Count == 0)
        {
            syncStatuses.Clear();
            return;
        }
        
        try
        {
            var statuses = await CertificateSyncService.GetCertificateStatusesAsync(certificates);
            syncStatuses = statuses.ToDictionary(s => s.CertificateId, s => s);
        }
        catch (Exception ex)
        {
            Logger.LogError($"Failed to load sync statuses: {ex.Message}", ex);
            syncStatuses.Clear();
        }
    }

    private void ShowCreateDialog()
    {
        newCertType = "IOS_DEVELOPMENT";
        newCertCommonName = "";
        newCertPassphrase = "";
        showCreateDialog = true;
        _ = InitModalAsync("create-cert-modal");
    }

    private void CloseCreateDialog()
    {
        showCreateDialog = false;
        _ = DisposeModalAsync("create-cert-modal");
    }
    
    private async Task ShowExportDialog(AppleCertificate cert)
    {
        exportCertificate = cert;
        exportType = "p12";
        exportWithPassword = false;
        exportPassword = "";
        exportPasswordConfirm = "";
        
        // Load local identities to check if we have the private key
        if (LocalCertificateService.IsSupported)
        {
            localIdentities = await LocalCertificateService.GetSigningIdentitiesAsync();
        }
        
        showExportDialog = true;
        _ = InitModalAsync("export-cert-modal");
    }
    
    private void CloseExportDialog()
    {
        showExportDialog = false;
        exportCertificate = null;
        _ = DisposeModalAsync("export-cert-modal");
    }
    
    private async Task ExportCertificate()
    {
        if (exportCertificate == null) return;
        
        isExporting = true;
        StateHasChanged();
        
        try
        {
            var cert = exportCertificate;
            var fileName = $"{cert.Name?.Replace(" ", "_") ?? "certificate"}_{DateTime.Now:yyyyMMdd}";
            byte[] data;
            string extension;
            
            if (exportType == "p12")
            {
                extension = ".p12";
                var matchingIdentity = localIdentities?.FirstOrDefault(i => 
                    SerialsMatch(i.SerialNumber, cert.SerialNumber));
                
                if (matchingIdentity == null)
                {
                    await AlertService.ShowAlertAsync("Error", "Private key not found in local keychain.");
                    return;
                }
                
                var password = exportWithPassword ? exportPassword : "";
                data = await LocalCertificateService.ExportP12Async(matchingIdentity.Identity, password);
            }
            else
            {
                extension = ".cer";
                data = await LocalCertificateService.ExportCertificateAsync(cert.SerialNumber ?? "");
            }
            
            // Get save location
            var savePath = await DialogService.ShowFileDialogAsync(
                "Save Certificate", 
                isSave: true, 
                defaultFileName: fileName + extension);
            
            if (string.IsNullOrEmpty(savePath))
            {
                return; // User cancelled
            }
            
            await File.WriteAllBytesAsync(savePath, data);
            await AlertService.ShowToastAsync($"Certificate exported to {Path.GetFileName(savePath)}");
            CloseExportDialog();
        }
        catch (Exception ex)
        {
            Logger.LogError($"Export failed: {ex}");
            await AlertService.ShowAlertAsync("Export Failed", ex.Message);
        }
        finally
        {
            isExporting = false;
            StateHasChanged();
        }
    }

    private async Task CreateCertificate()
    {
        showCreateDialog = false;
        _ = DisposeModalAsync("create-cert-modal");
        
        var commonName = string.IsNullOrWhiteSpace(newCertCommonName) ? null : newCertCommonName;
        var passphrase = string.IsNullOrWhiteSpace(newCertPassphrase) ? null : newCertPassphrase;
        
        var result = await OperationModal.RunAsync(
            "Create Certificate",
            $"Creating {newCertType} certificate...",
            async ctx =>
            {
                ctx.SetStatus("Generating certificate signing request...");
                ctx.LogInfo($"Certificate type: {newCertType}");
                if (!string.IsNullOrEmpty(commonName))
                    ctx.LogInfo($"Common name: {commonName}");
                
                var certResult = await AppleService.CreateCertificateAsync(newCertType, commonName, passphrase);
                
                ctx.SetStatus("Saving certificate to Downloads...");
                var fileName = $"certificate_{newCertType}_{DateTime.Now:yyyyMMdd_HHmmss}.pfx";
                var downloadsPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), "Downloads", fileName);
                await File.WriteAllBytesAsync(downloadsPath, certResult.PfxData);
                
                ctx.LogSuccess($"Certificate saved: ~/Downloads/{fileName}");
                ctx.LogInfo($"Expires: {certResult.ExpirationDate:MMM dd, yyyy}");
                return true;
            },
            canCancel: false);

        if (result.Success)
        {
            await RefreshData(forceRefresh: true);
        }
    }

    private async Task RevokeCertificate(AppleCertificate cert)
    {
        var confirmed = await AlertService.ShowConfirmAsync(
            "Revoke Certificate",
            $"Are you sure you want to revoke '{cert.Name}'? This action cannot be undone and will invalidate any apps signed with this certificate.");
        
        if (!confirmed) return;

        var result = await OperationModal.RunAsync(
            "Revoke Certificate",
            $"Revoking '{cert.Name}'...",
            async ctx =>
            {
                ctx.SetStatus("Revoking certificate...");
                ctx.LogInfo($"Certificate: {cert.Name}");
                ctx.LogInfo($"Serial: {cert.SerialNumber}");
                
                await AppleService.RevokeCertificateAsync(cert.Id);
                ctx.LogSuccess("Certificate revoked successfully");
                return true;
            },
            canCancel: false);

        if (result.Success)
        {
            await RefreshData(forceRefresh: true);
        }
    }
    
    private async Task DeleteLocalCertificate(AppleCertificate cert)
    {
        openSyncMenuCertId = null;
        
        if (!LocalCertificateService.IsSupported)
        {
            await AlertService.ShowAlertAsync("Not Supported", "Certificate deletion is only supported on macOS.");
            return;
        }
        
        // Confirm deletion
        var confirmed = await AlertService.ShowConfirmAsync(
            "Delete from Keychain",
            $"Are you sure you want to delete '{cert.Name}' from your local keychain?\n\nThis will remove both the certificate and its private key. This action cannot be undone.");
        
        if (!confirmed)
            return;
        
        try
        {
            // Find the matching local identity
            var identities = await LocalCertificateService.GetSigningIdentitiesAsync();
            var matchingIdentity = identities.FirstOrDefault(i => 
                SerialsMatch(i.SerialNumber, cert.SerialNumber));
            
            if (matchingIdentity == null)
            {
                await AlertService.ShowAlertAsync("Not Found", "Certificate not found in local keychain.");
                return;
            }
            
            // Extract the common name from the identity for deletion
            // Identity looks like: "Apple Development: John Doe (TEAMID)"
            var commonName = matchingIdentity.Identity;
            
            await LocalCertificateService.DeleteCertificateAsync(commonName);
            await AlertService.ShowToastAsync("Certificate deleted from keychain");
            
            // Invalidate cache and refresh sync statuses
            LocalCertificateService.InvalidateCache();
            await LoadSyncStatuses();
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError($"Failed to delete certificate: {ex}");
            await AlertService.ShowAlertAsync("Delete Failed", ex.Message);
        }
    }

    private async Task DeleteFromCloud(AppleCertificate cert)
    {
        openSyncMenuCertId = null;
        
        if (string.IsNullOrEmpty(cert.SerialNumber))
        {
            await AlertService.ShowAlertAsync("Error", "Certificate serial number is not available.");
            return;
        }
        
        // Confirm deletion
        var confirmed = await AlertService.ShowConfirmAsync(
            "Delete from Cloud",
            $"Are you sure you want to delete '{cert.Name}' from cloud storage?\n\nThis will remove the private key from your cloud secrets provider. This action cannot be undone.");
        
        if (!confirmed)
            return;
        
        try
        {
            var success = await CertificateSyncService.DeleteFromCloudAsync(cert.SerialNumber);
            
            if (success)
            {
                await AlertService.ShowToastAsync("Certificate deleted from cloud");
                
                // Refresh sync statuses
                await LoadSyncStatuses();
                StateHasChanged();
            }
            else
            {
                await AlertService.ShowAlertAsync("Delete Failed", "Failed to delete certificate from cloud storage.");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError($"Failed to delete certificate from cloud: {ex}");
            await AlertService.ShowAlertAsync("Delete Failed", ex.Message);
        }
    }

    private async Task SyncAllFromCloud()
    {
        // Get all cloud-only certificates
        var cloudOnlyCerts = certificates
            .Where(c => syncStatuses.TryGetValue(c.Id, out var status) && status.Location == SecretLocation.CloudOnly)
            .ToList();

        if (cloudOnlyCerts.Count == 0)
        {
            await AlertService.ShowToastAsync("No certificates to install from cloud");
            return;
        }

        var operations = cloudOnlyCerts.Select(cert => new OperationItem(
            Id: cert.Id,
            Name: cert.Name,
            Description: $"{FormatCertType(cert.CertificateType ?? "Unknown")} - {cert.SerialNumber}",
            Execute: async ctx =>
            {
                ctx.LogInfo($"Installing {cert.Name} from cloud...");
                
                try
                {
                    var success = await CertificateSyncService.DownloadAndInstallAsync(cert.Id);
                    
                    if (success)
                    {
                        ctx.LogSuccess($"Installed {cert.Name} to local keychain");
                        return true;
                    }
                    else
                    {
                        ctx.LogError($"Failed to install {cert.Name}");
                        return false;
                    }
                }
                catch (Exception ex)
                {
                    ctx.LogError($"Error installing {cert.Name}: {ex.Message}");
                    return false;
                }
            },
            IsEnabled: true,
            CanDisable: true
        )).ToList();

        var result = await MultiOpModal.RunAsync(
            "Install Certificates from Cloud",
            $"The following {cloudOnlyCerts.Count} certificate(s) will be installed to your local keychain. Uncheck any you want to skip.",
            operations);

        if (result.Completed > 0)
        {
            // Refresh local identities cache and sync statuses
            LocalCertificateService.InvalidateCache();
            await LoadSyncStatuses();
            StateHasChanged();
        }
    }

    private async Task SyncAllToCloud()
    {
        // Get all local-only certificates
        var localOnlyCerts = certificates
            .Where(c => syncStatuses.TryGetValue(c.Id, out var status) && status.Location == SecretLocation.LocalOnly)
            .ToList();

        if (localOnlyCerts.Count == 0)
        {
            await AlertService.ShowToastAsync("No certificates to upload to cloud");
            return;
        }

        // Get local identities for P12 export
        var identities = await LocalCertificateService.GetSigningIdentitiesAsync();

        var operations = localOnlyCerts.Select(cert => new OperationItem(
            Id: cert.Id,
            Name: cert.Name,
            Description: $"{FormatCertType(cert.CertificateType ?? "Unknown")} - {cert.SerialNumber}",
            Execute: async ctx =>
            {
                ctx.LogInfo($"Uploading {cert.Name} to cloud...");
                
                try
                {
                    // Find matching local identity
                    var identity = identities.FirstOrDefault(i =>
                        SerialsMatch(i.SerialNumber, cert.SerialNumber));
                    
                    if (identity == null)
                    {
                        ctx.LogError($"Could not find local identity for {cert.Name}");
                        return false;
                    }

                    // Generate a random password for the P12
                    var password = GenerateRandomPassword();
                    
                    // Export P12 from keychain
                    ctx.LogInfo("Exporting certificate from keychain...");
                    var p12Data = await LocalCertificateService.ExportP12Async(identity.Identity, password);
                    
                    // Upload to cloud
                    ctx.LogInfo("Uploading to cloud storage...");
                    var metadata = new CertificateSecretMetadata(
                        CertificateId: cert.Id,
                        SerialNumber: cert.SerialNumber ?? "",
                        CommonName: cert.Name,
                        CertificateType: cert.CertificateType ?? "Unknown",
                        ExpirationDate: cert.ExpirationDate,
                        CreatedByMachine: Environment.MachineName,
                        CreatedAt: DateTime.UtcNow
                    );
                    
                    var success = await CertificateSyncService.UploadToCloudAsync(cert, p12Data, password, metadata);
                    
                    if (success)
                    {
                        ctx.LogSuccess($"Uploaded {cert.Name} to cloud");
                        return true;
                    }
                    else
                    {
                        ctx.LogError($"Failed to upload {cert.Name}");
                        return false;
                    }
                }
                catch (Exception ex)
                {
                    ctx.LogError($"Error uploading {cert.Name}: {ex.Message}");
                    return false;
                }
            },
            IsEnabled: true,
            CanDisable: true
        )).ToList();

        var result = await MultiOpModal.RunAsync(
            "Upload Certificates to Cloud",
            $"The following {localOnlyCerts.Count} certificate(s) will be uploaded to cloud storage. Uncheck any you want to skip.",
            operations);

        if (result.Completed > 0)
        {
            await LoadSyncStatuses();
            StateHasChanged();
        }
    }

    private static bool SerialsMatch(string? a, string? b)
        => (a ?? "").TrimStart('0').Equals((b ?? "").TrimStart('0'), StringComparison.OrdinalIgnoreCase);

    private string FormatCertType(string? certType)
    {
        if (string.IsNullOrEmpty(certType))
            return "Unknown";
            
        return certType.Replace("_", " ").ToLowerInvariant() switch
        {
            var t when t.Contains("development") => "Development",
            var t when t.Contains("distribution") => "Distribution",
            var t when t.Contains("push") => "Push Notification",
            var t when t.Contains("developer id application") => "Developer ID App",
            var t when t.Contains("developer id installer") => "Developer ID Installer",
            var t when t.Contains("developer id") => "Developer ID",
            _ => certType.Replace("_", " ")
        };
    }

    private string FormatPlatform(string? platform)
    {
        if (string.IsNullOrEmpty(platform) || platform.Equals("Unknown", StringComparison.OrdinalIgnoreCase))
            return "";
            
        return platform.ToUpperInvariant() switch
        {
            "IOS" => "iOS",
            "MAC_OS" or "MACOS" => "macOS",
            "TV_OS" or "TVOS" => "tvOS",
            "VISION_OS" or "VISIONOS" => "visionOS",
            "UNIVERSAL" => "Universal",
            _ => platform.Replace("_", " ") // Fall back to cleaned-up original value
        };
    }

    private static string GenerateRandomPassword()
    {
        return Convert.ToBase64String(Guid.NewGuid().ToByteArray())[..16];
    }

    private async Task CopyToClipboard(string text)
    {
        await DialogService.CopyToClipboardAsync(text);
        await AlertService.ShowToastAsync("Copied to clipboard");
    }
    
    // Sync helper methods
    
    private SecretLocation GetSyncStatus(AppleCertificate cert)
    {
        if (syncStatuses.TryGetValue(cert.Id ?? "", out var status))
            return status.Location;
        return SecretLocation.None;
    }
    
    private string GetSyncBadgeClass(SecretLocation location) => location switch
    {
        SecretLocation.Both => "badge-sync-both",
        SecretLocation.LocalOnly => "badge-sync-local",
        SecretLocation.CloudOnly => "badge-sync-cloud",
        _ => "badge-sync-none"
    };
    
    private string GetSyncStatusIcon(SecretLocation location) => location switch
    {
        SecretLocation.Both => "🟢",
        SecretLocation.LocalOnly => "🔵",
        SecretLocation.CloudOnly => "🟡",
        _ => "⚫"
    };
    
    private string GetSyncStatusText(SecretLocation location) => location switch
    {
        SecretLocation.Both => "Synced",
        SecretLocation.LocalOnly => "Local",
        SecretLocation.CloudOnly => "Cloud",
        _ => "No Key"
    };
    
    private string GetSyncStatusTooltip(SecretLocation location) => location switch
    {
        SecretLocation.Both => "Private key exists locally and in cloud storage",
        SecretLocation.LocalOnly => "Private key exists locally only - can upload to cloud",
        SecretLocation.CloudOnly => "Private key in cloud only - can install locally",
        _ => "No private key available - cannot sign with this certificate"
    };
    
    private void ToggleSyncMenu(string? certId)
    {
        openSyncMenuCertId = openSyncMenuCertId == certId ? null : certId;
    }
    
    private async void HandleUploadClick(string certId)
    {
        try
        {
            Logger.LogInformation($"HandleUploadClick called for cert ID: {certId}");
            var cert = certificates?.FirstOrDefault(c => c.Id == certId);
            if (cert != null)
            {
                await UploadToCloud(cert);
            }
            else
            {
                await AlertService.ShowAlertAsync("Error", $"Could not find cert with ID: {certId}");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError($"HandleUploadClick error: {ex}");
            await AlertService.ShowAlertAsync("Error", $"Upload failed: {ex.Message}");
        }
    }
    
    private void HandleInstallClick(string certId)
    {
        Logger.LogInformation($"HandleInstallClick called for cert ID: {certId}");
        var cert = certificates?.FirstOrDefault(c => c.Id == certId);
        if (cert != null)
        {
            _ = InstallLocally(cert);
        }
    }
    
    private async Task UploadToCloud(AppleCertificate cert)
    {
        try
        {
            Logger.LogInformation($"UploadToCloud called for cert: {cert.Id} ({cert.Name})");
            openSyncMenuCertId = null;
            StateHasChanged();
            
            // We need to get the P12 from the local keychain
            if (!LocalCertificateService.IsSupported)
            {
                await AlertService.ShowAlertAsync("Not Supported", "Certificate export is only supported on macOS.");
                return;
            }
            
            // Get the local signing identities to find the matching one
            Logger.LogInformation($"Looking for identity with serial: {cert.SerialNumber}");
            var identities = await LocalCertificateService.GetSigningIdentitiesAsync();
            var matchingIdentity = identities.FirstOrDefault(i => 
                SerialsMatch(i.SerialNumber, cert.SerialNumber));
            
            if (matchingIdentity == null)
            {
                Logger.LogWarning($"No matching identity found for serial {cert.SerialNumber}");
                await AlertService.ShowAlertAsync("Not Found", "Could not find the private key for this certificate in your local keychain.");
                return;
            }
            
            Logger.LogInformation($"Found matching identity: {matchingIdentity.Identity}");
            
            // Generate a random password for the P12 - user doesn't need to know it since we store it in cloud
            var password = Convert.ToBase64String(Guid.NewGuid().ToByteArray())[..16];
        
            var result = await OperationModal.RunAsync(
                "Upload to Cloud",
                $"Exporting and uploading certificate...",
                async ctx =>
                {
                    ctx.LogInfo("Exporting certificate from keychain...");
                    var p12Data = await LocalCertificateService.ExportP12Async(matchingIdentity.Identity, password);
                    
                    ctx.LogInfo("Uploading to cloud storage...");
                    var metadata = new CertificateSecretMetadata(
                        cert.Id ?? "",
                        cert.SerialNumber ?? "",
                        cert.Name ?? "",
                        cert.CertificateType ?? "",
                        cert.ExpirationDate,
                        Environment.MachineName,
                        DateTime.UtcNow
                    );
                    
                    var success = await CertificateSyncService.UploadToCloudAsync(cert, p12Data, password, metadata);
                    if (!success)
                        throw new Exception("Failed to upload certificate to cloud storage");
                    
                    return true;
            },
            canCancel: false);
        
        if (result.Success)
        {
            await AlertService.ShowToastAsync("Certificate uploaded to cloud");
            await LoadSyncStatuses();
            StateHasChanged();
        }
        }
        catch (Exception ex)
        {
            Logger.LogError($"Error in UploadToCloud: {ex}");
            await AlertService.ShowAlertAsync("Error", $"Upload failed: {ex.Message}");
        }
    }
    
    private async Task InstallLocally(AppleCertificate cert)
    {
        openSyncMenuCertId = null;
        
        if (!LocalCertificateService.IsSupported)
        {
            await AlertService.ShowAlertAsync("Not Supported", "Certificate installation is only supported on macOS.");
            return;
        }
        
        Logger.LogInformation($"InstallLocally starting for cert: {cert.Id}, serial: {cert.SerialNumber}");
        
        var result = await OperationModal.RunAsync(
            "Install Certificate",
            $"Downloading and installing certificate...",
            async ctx =>
            {
                ctx.LogInfo($"Certificate: {cert.Name}");
                ctx.LogInfo($"Serial: {cert.SerialNumber}");
                ctx.LogInfo("Downloading from cloud storage...");
                
                // Use the CertificateSyncService to download and install
                if (CertificateSyncService is MauiSherpa.Core.Services.CertificateSyncService syncService)
                {
                    var success = await syncService.DownloadAndInstallBySerialAsync(cert.SerialNumber ?? "");
                    if (!success)
                    {
                        ctx.LogError("Failed to download and install certificate");
                        throw new Exception("Failed to download and install certificate - check logs for details");
                    }
                    ctx.LogSuccess("Certificate installed successfully");
                    return true;
                }
                else
                {
                    throw new Exception("Sync service not available");
                }
            },
            canCancel: false);
        
        if (result.Success)
        {
            await AlertService.ShowToastAsync("Certificate installed to local keychain");
            LocalCertificateService.InvalidateCache();
            await LoadSyncStatuses();
            StateHasChanged();
        }
    }

    private DotNetObjectReference<Certificates>? _dotNetRef;
    private readonly HashSet<string> _activeModals = new();

    private async Task InitModalAsync(string modalId)
    {
        await Task.Yield();
        _dotNetRef ??= DotNetObjectReference.Create(this);
        _activeModals.Add(modalId);
        await JS.InvokeVoidAsync("modalInterop.initialize", modalId, _dotNetRef);
    }

    private async Task DisposeModalAsync(string modalId)
    {
        _activeModals.Remove(modalId);
        try { await JS.InvokeVoidAsync("modalInterop.dispose", modalId); } catch { }
    }

    [JSInvokable]
    public void OnEscapePressed()
    {
        if (showExportDialog)
            CloseExportDialog();
        else if (showCreateDialog)
            CloseCreateDialog();
        InvokeAsync(StateHasChanged);
    }
}
